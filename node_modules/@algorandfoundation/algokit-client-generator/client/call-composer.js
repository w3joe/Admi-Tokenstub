'use strict';

var writer = require('../output/writer.js');
var getCallConfigSummary = require('./helpers/get-call-config-summary.js');
var deployTypes = require('./deploy-types.js');
var algosdk = require('algosdk');

function* composeMethod(ctx) {
    const { name, callConfig } = ctx;
    // todo: Patrick feedback - allow common params to be passed in here so they propagate to all params calls e.g. firstValid
    yield `public newGroup(): ${name}Composer {`;
    yield writer.IncIndent;
    yield `const client = this`;
    yield `const composer = this.algorand.newGroup()`;
    yield `let promiseChain:Promise<unknown> = Promise.resolve()`;
    yield `const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []`;
    yield `return {`;
    yield writer.IncIndent;
    yield* callComposerNoops(ctx);
    if (ctx.mode === 'full') {
        yield* callComposerOperationMethods(ctx, callConfig.updateMethods, 'update', true);
        yield* callComposerOperationMethods(ctx, callConfig.deleteMethods, 'delete');
    }
    yield* callComposerOperationMethods(ctx, callConfig.optInMethods, 'optIn');
    yield* callComposerOperationMethods(ctx, callConfig.closeOutMethods, 'closeOut');
    yield* callComposerClearState(ctx);
    yield `addTransaction(txn: Transaction, signer?: TransactionSigner) {`;
    yield writer.IncIndent;
    yield 'promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))';
    yield 'return this';
    yield writer.DecIndent;
    yield '},';
    yield `async composer() {`;
    yield writer.IncIndent;
    yield `await promiseChain`;
    yield 'return composer';
    yield writer.DecIndent;
    yield '},';
    yield `async simulate(options?: SimulateOptions) {`;
    yield writer.IncIndent;
    yield `await promiseChain`;
    yield `const result = await (!options ? composer.simulate() : composer.simulate(options))`;
    yield `return {`;
    yield writer.IncIndent;
    yield `...result,`;
    yield `returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)`;
    yield writer.DecIndentAndCloseBlock;
    yield writer.DecIndent;
    yield '},';
    yield `async send(params?: SendParams) {`;
    yield writer.IncIndent;
    yield `await promiseChain`;
    yield `const result = await composer.send(params)`;
    yield `return {`;
    yield writer.IncIndent;
    yield `...result,`;
    yield `returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)`;
    yield writer.DecIndentAndCloseBlock;
    yield writer.DecIndentAndCloseBlock;
    yield writer.DecIndent;
    yield `} as unknown as ${name}Composer`;
    yield writer.DecIndentAndCloseBlock;
}
function* callComposerNoops({ app, name, callConfig, methodSignatureToUniqueName, sanitizer }) {
    if (callConfig.callMethods.includes(getCallConfigSummary.BARE_CALL)) {
        yield* writer.jsDoc(`Add a bare method call to the ${app.name} contract`);
        yield `bare(params: AppClientBareCallParams & ${deployTypes.getCallOnCompleteOptions(getCallConfigSummary.BARE_CALL, app).type}) {`;
        yield writer.IncIndent;
        yield `promiseChain = promiseChain.then(() => composer.addAppCall(client.params.bare(params)))`;
        yield `return this`;
        yield writer.DecIndent;
        yield '},';
    }
    for (const methodSignature of callConfig.callMethods.filter((m) => m !== getCallConfigSummary.BARE_CALL).map((m) => m)) {
        const methodName = sanitizer.makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature]);
        const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(methodSignature);
        const methodNameAccessor = sanitizer.getSafeMemberAccessor(methodName);
        // Skip methods which don't support a no_op call config
        if (!callConfig.callMethods.includes(methodSignature))
            continue;
        yield* writer.jsDoc(`Add a ${methodSignature} method call against the ${app.name} contract`);
        yield `${methodName}(params: CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']> & ${deployTypes.getCallOnCompleteOptions(methodSignature, app).type}) {`;
        yield writer.IncIndent;
        yield `promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params${methodNameAccessor}(params)))`;
        const outputTypeName = app.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === methodSignature)?.returns.type;
        yield `resultMappers.push(${outputTypeName && outputTypeName !== 'void' ? `(v) => client.decodeReturnValue('${methodSigSafe}', v)` : 'undefined'})`;
        yield `return this`;
        yield writer.DecIndent;
        yield '},';
    }
}
function* callComposerClearState({ app }) {
    yield* writer.jsDoc(`Add a clear state call to the ${app.name} contract`);
    yield `clearState(params: AppClientBareCallParams) {`;
    yield writer.IncIndent;
    yield `promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))`;
    yield `return this`;
    yield writer.DecIndent;
    yield '},';
}
function* callComposerOperationMethods({ app, name, methodSignatureToUniqueName, sanitizer }, methods, verb, includeCompilation) {
    const callType = verb === 'update' ? 'Update' : verb === 'delete' ? 'Delete' : 'Call';
    if (methods.length) {
        yield `get ${verb}() {`;
        yield writer.IncIndent;
        yield `return {`;
        yield writer.IncIndent;
        for (const methodSig of methods) {
            if (methodSig === getCallConfigSummary.BARE_CALL) {
                yield `bare: (params?: AppClientBareCallParams ${includeCompilation ? '& AppClientCompilationParams ' : ''}) => {`;
                yield writer.IncIndent;
                yield `promiseChain = promiseChain.then(${verb === 'update' ? 'async ' : ''}() => composer.addApp${callType}(${verb === 'update' ? 'await ' : ''}client.params.${verb}.bare(params)))`;
                yield `return this`;
                yield writer.DecIndent;
                yield '},';
            }
            else {
                const uniqueName = methodSignatureToUniqueName[methodSig];
                const methodName = sanitizer.makeSafeMethodIdentifier(uniqueName);
                const methodNameAccessor = sanitizer.getSafeMemberAccessor(methodName);
                const methodSigSafe = sanitizer.makeSafeStringTypeLiteral(methodSig);
                yield `${methodName}: (params: CallParams<${name}Args['obj']['${methodSigSafe}'] | ${name}Args['tuple']['${methodSigSafe}']>${includeCompilation ? ' & AppClientCompilationParams' : ''}) => {`;
                yield writer.IncIndent;
                yield `promiseChain = promiseChain.then(async () => composer.addApp${callType}MethodCall(await client.params.${verb}${methodNameAccessor}(params)))`;
                const outputTypeName = app.methods.find((m) => new algosdk.ABIMethod(m).getSignature() === methodSig)?.returns.type;
                yield `resultMappers.push(${outputTypeName && outputTypeName !== 'void' ? `(v) => client.decodeReturnValue('${methodSigSafe}', v)` : 'undefined'})`;
                yield `return this`;
                yield writer.DecIndent;
                yield '},';
            }
        }
        yield writer.DecIndentAndCloseBlock;
        yield writer.DecIndent;
        yield '},';
    }
}

exports.composeMethod = composeMethod;
//# sourceMappingURL=call-composer.js.map
