"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dryrunTxnResultLogicSigTrace = exports.dryrunTxnResultAppTrace = exports.createDryrun = void 0;
const types_js_1 = require("./client/v2/algod/models/types.js");
const address_js_1 = require("./encoding/address.js");
const binarydata_js_1 = require("./encoding/binarydata.js");
const index_js_1 = require("./types/transactions/index.js");
const utils_js_1 = require("./utils/utils.js");
const defaultAppId = 1380011588;
const defaultMaxWidth = 30;
/**
 * createDryrun takes an Algod Client (from algod.AlgodV2Client) and an array of Signed Transactions
 * from (transaction.SignedTransaction) and creates a DryrunRequest object with relevant balances
 * @param client - the AlgodClient to make requests against
 * @param txns - the array of SignedTransaction to use for generating the DryrunRequest object
 * @param protocolVersion - the string representing the protocol version to use
 * @param latestTimestamp - the timestamp
 * @param round - the round available to some TEAL scripts. Defaults to the current round on the network.
 * @param sources - TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.
 * @returns the DryrunRequest object constructed from the SignedTransactions passed
 */
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources, }) {
    const appInfos = [];
    const acctInfos = [];
    const apps = [];
    const assets = [];
    const accts = [];
    for (const t of txns) {
        if (t.txn.type === index_js_1.TransactionType.appl) {
            accts.push(t.txn.sender.toString());
            accts.push(...t.txn.applicationCall.accounts.map((a) => a.toString()));
            apps.push(...t.txn.applicationCall.foreignApps);
            accts.push(...t.txn
                .applicationCall.foreignApps.map(address_js_1.getApplicationAddress)
                .map((a) => a.toString()));
            assets.push(...t.txn.applicationCall.foreignAssets);
            // Create application,
            if (t.txn.applicationCall.appIndex === BigInt(0)) {
                appInfos.push(new types_js_1.Application({
                    id: defaultAppId,
                    params: new types_js_1.ApplicationParams({
                        creator: t.txn.sender.toString(),
                        approvalProgram: t.txn.applicationCall.approvalProgram,
                        clearStateProgram: t.txn.applicationCall.clearProgram,
                        localStateSchema: new types_js_1.ApplicationStateSchema({
                            numUint: t.txn.applicationCall.numLocalInts,
                            numByteSlice: t.txn.applicationCall.numLocalByteSlices,
                        }),
                        globalStateSchema: new types_js_1.ApplicationStateSchema({
                            numUint: t.txn.applicationCall.numGlobalInts,
                            numByteSlice: t.txn.applicationCall.numGlobalByteSlices,
                        }),
                    }),
                }));
            }
            else {
                const { appIndex } = t.txn.applicationCall;
                apps.push(appIndex);
                accts.push((0, address_js_1.getApplicationAddress)(appIndex).toString());
            }
        }
    }
    // Dedupe and add creator to accts array
    const assetPromises = [];
    for (const assetId of new Set(assets)) {
        assetPromises.push(client
            .getAssetByID(assetId)
            .do()
            .then((assetInfo) => {
            accts.push(assetInfo.params.creator);
        }));
    }
    // Wait for assets to finish since we append to accts array
    await Promise.all(assetPromises);
    // Dedupe and get app info for all apps
    const appPromises = [];
    for (const appId of new Set(apps)) {
        appPromises.push(client
            .getApplicationByID(appId)
            .do()
            .then((appInfo) => {
            appInfos.push(appInfo);
            accts.push(appInfo.params.creator.toString());
        }));
    }
    await Promise.all(appPromises);
    const acctPromises = [];
    for (const acct of new Set(accts)) {
        acctPromises.push(client
            .accountInformation(acct)
            .do()
            .then((acctInfo) => {
            acctInfos.push(acctInfo);
        }));
    }
    await Promise.all(acctPromises);
    return new types_js_1.DryrunRequest({
        txns: txns.slice(),
        accounts: acctInfos,
        apps: appInfos,
        latestTimestamp: latestTimestamp ?? 0,
        round: round ?? 0,
        protocolVersion: protocolVersion ?? '',
        sources: sources ?? [],
    });
}
exports.createDryrun = createDryrun;
function truncate(str, maxValueWidth) {
    if (str.length > maxValueWidth && maxValueWidth > 0) {
        return `${str.slice(0, maxValueWidth)}...`;
    }
    return str;
}
function scratchToString(prevScratch, currScratch) {
    if (currScratch.length === 0)
        return '';
    let newScratchIdx = null;
    for (let idx = 0; idx < currScratch.length; idx++) {
        if (idx > prevScratch.length) {
            newScratchIdx = idx;
            continue;
        }
        if ((0, utils_js_1.stringifyJSON)(prevScratch[idx]) !== (0, utils_js_1.stringifyJSON)(currScratch[idx])) {
            newScratchIdx = idx;
        }
    }
    if (newScratchIdx == null)
        return '';
    const newScratch = currScratch[newScratchIdx];
    if (newScratch.bytes.length > 0) {
        return `${newScratchIdx} = 0x${(0, binarydata_js_1.bytesToHex)(newScratch.bytes)}`;
    }
    return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
    const svs = reverse ? stack.reverse() : stack;
    return `[${svs
        .map((sv) => {
        switch (sv.type) {
            case 1:
                return `0x${(0, binarydata_js_1.bytesToHex)(sv.bytes)}`;
            case 2:
                return sv.uint.toString();
            default:
                return '';
        }
    })
        .join(', ')}]`;
}
function dryrunTrace(trace, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    // Create the array of arrays, each sub array contains N columns
    const lines = [['pc#', 'ln#', 'source', 'scratch', 'stack']];
    for (let idx = 0; idx < trace.length; idx++) {
        const { line, error, pc, scratch, stack } = trace[idx];
        const currScratch = scratch !== undefined ? scratch : [];
        const prevScratch = idx > 0 && trace[idx - 1].scratch !== undefined
            ? trace[idx - 1].scratch
            : [];
        const src = !error ? disassembly[line] : `!! ${error} !!`;
        lines.push([
            pc.toString().padEnd(3, ' '),
            line.toString().padEnd(3, ' '),
            truncate(src, maxWidth),
            truncate(scratchToString(prevScratch, currScratch), maxWidth),
            truncate(stackToString(stack, spc.topOfStackFirst), maxWidth),
        ]);
    }
    // Get the max length for each column
    const maxLengths = lines.reduce((prev, curr) => {
        const newVal = new Array(lines[0].length).fill(0);
        for (let idx = 0; idx < prev.length; idx++) {
            newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
        }
        return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines
        .map((line) => line
        .map((v, idx) => v.padEnd(maxLengths[idx] + 1, ' '))
        .join('|')
        .trim())
        .join('\n')}\n`;
}
function dryrunTxnResultAppTrace(result, spc) {
    if (!result.appCallTrace || !result.disassembly)
        return '';
    let conf = spc;
    if (spc !== undefined)
        conf = spc;
    else {
        conf = {
            maxValueWidth: defaultMaxWidth,
            topOfStackFirst: false,
        };
    }
    return dryrunTrace(result.appCallTrace, result.disassembly, conf);
}
exports.dryrunTxnResultAppTrace = dryrunTxnResultAppTrace;
function dryrunTxnResultLogicSigTrace(result, spc) {
    if (!result.logicSigTrace || !result.logicSigDisassembly)
        return '';
    let conf;
    if (spc !== undefined)
        conf = spc;
    else {
        conf = {
            maxValueWidth: defaultMaxWidth,
            topOfStackFirst: true,
        };
    }
    return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);
}
exports.dryrunTxnResultLogicSigTrace = dryrunTxnResultLogicSigTrace;
//# sourceMappingURL=dryrun.js.map